<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>One-Dimensional Convexification · NumericalRelaxation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="NumericalRelaxation.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="NumericalRelaxation.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NumericalRelaxation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>One-Dimensional Convexification</a><ul class="internal"><li><a class="tocitem" href="#Equidistant-Convexificationstrategy"><span>Equidistant Convexificationstrategy</span></a></li><li><a class="tocitem" href="#Adaptive-Convexification"><span>Adaptive Convexification</span></a></li></ul></li><li><a class="tocitem" href="../r1convexification/">Rank-One Convexification</a></li><li><a class="tocitem" href="../polyconvexification/">Polyconvexification</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>One-Dimensional Convexification</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>One-Dimensional Convexification</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/koehlerson/NumericalRelaxation.jl/blob/main/docs/src/api/oned-convexification.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="One-Dimensional-Convexification"><a class="docs-heading-anchor" href="#One-Dimensional-Convexification">One-Dimensional Convexification</a><a id="One-Dimensional-Convexification-1"></a><a class="docs-heading-anchor-permalink" href="#One-Dimensional-Convexification" title="Permalink"></a></h1><p>This packages&#39;s focus is the (semi-)convexification of a generalized energy density <span>$W(\boldsymbol{F})$</span> that depends on the gradient of the solution <span>$\nabla \boldsymbol{u}$</span>.</p><p>First, a strategy needs to be instantiated, which only holds the parameters of the convexification, such as discretization interval, size of the discretization etc. This strategy needs to be of subtype <code>&lt;: AbstractConvexification</code> and dispatches <code>build_buffer</code>. The latter mentioned will return a buffer that is needed together with the convexification strategy to call <code>convexify</code>.</p><article class="docstring"><header><a class="docstring-binding" id="NumericalRelaxation.convexify" href="#NumericalRelaxation.convexify"><code>NumericalRelaxation.convexify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convexify(graham::GrahamScan{T2}, buffer::ConvexificationBuffer1D{T1,T2}, W::FUN, F, xargs::Vararg{Any,XN}) where {T1,T2,FUN,XN}  -&gt; W_convex::Float64, F⁻::Tensor{2,1}, F⁺::Tensor{2,1}</code></pre><p>Function that implements the convexification on equidistant grid without deletion in <span>$\mathcal{O}(N)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/koehlerson/NumericalRelaxation.jl/blob/4b1ab414c0f5dc893645f4295da8681e40bca071/src/convexify.jl#L27-L30">source</a></section><section><div><pre><code class="nohighlight hljs">convexify(adaptivegraham::AdaptiveGrahamScan{T2}, buffer::AdaptiveConvexificationBuffer1D{T1,T2}, W::FUN, F::T1, xargs::Vararg{Any,XN}) where {T1,T2,FUN,XN}  -&gt; W_convex::Float64, F⁻::Tensor{2,1}, F⁺::Tensor{2,1}</code></pre><p>Function that implements the adaptive Graham&#39;s scan convexification without deletion in <span>$\mathcal{O}(N)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/koehlerson/NumericalRelaxation.jl/blob/4b1ab414c0f5dc893645f4295da8681e40bca071/src/convexify.jl#L105-L108">source</a></section><section><div><p>Signed singular value polyconvexification using the linear programming approach. Compute approximation to the singular value polycovex envelope of the function <code>Φ</code> which is the reformulation of the isotropic function <code>W</code> in terms of signed singular values <span>$Φ(ν) = W(diagm(ν))$</span>, at the point <code>ν</code> via the linear programming approach as discussed in      <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> Timo Neumeier, Malte A. Peter, Daniel Peterseim, David Wiedemann.     Computational polyconvexification of isotropic functions, arXiv 2307.15676, 2023. The parameters <code>nref</code> and <code>r</code> (stored in poly_convexification struct) discribe the grid by radius <code>r</code> (in the ∞ norm) and <code>nref</code> uniform mesh refinements. The points of the lifted grid which are involved in the minimization are marked by the Φactive buffer, and deliver <code>Φ</code> values smaller than infinity.</p><p><code>Φ::FUN</code> function in terms of signed singular values <code>Φ(ν) = W(diagm(ν))</code> <code>ν::Vector{Float64}</code> point of evaluation for the polyconvex hull <code>returnDerivs::Bool</code> return first order derivative information</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/koehlerson/NumericalRelaxation.jl/blob/4b1ab414c0f5dc893645f4295da8681e40bca071/src/convexify.jl#L1113-L1125">source</a></section><section><div><p>Signed singular value polyconvexification using the linear programming approach</p><p>takes dxd matrix <code>F</code> and function <code>W</code><span>$: \mathbb{R}^{d \times d} \to \mathbb{R}$</span>  (isotropic)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/koehlerson/NumericalRelaxation.jl/blob/4b1ab414c0f5dc893645f4295da8681e40bca071/src/convexify.jl#L1165-L1169">source</a></section></article><h2 id="Equidistant-Convexificationstrategy"><a class="docs-heading-anchor" href="#Equidistant-Convexificationstrategy">Equidistant Convexificationstrategy</a><a id="Equidistant-Convexificationstrategy-1"></a><a class="docs-heading-anchor-permalink" href="#Equidistant-Convexificationstrategy" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NumericalRelaxation.GrahamScan" href="#NumericalRelaxation.GrahamScan"><code>NumericalRelaxation.GrahamScan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GrahamScan{T&lt;:Number} &lt;: AbstractConvexification</code></pre><p>Datastructure that implements in <code>convexify</code> dispatch the discrete one-dimensional convexification of a line without deletion of memory. This results in a complexity of <span>$\mathcal{O}(N)$</span>.</p><p><strong>Kwargs</strong></p><ul><li><code>δ::T = 0.01</code></li><li><code>start::T = 0.9</code></li><li><code>stop::T = 20.0</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/koehlerson/NumericalRelaxation.jl/blob/4b1ab414c0f5dc893645f4295da8681e40bca071/src/convexify.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalRelaxation.ConvexificationBuffer1D" href="#NumericalRelaxation.ConvexificationBuffer1D"><code>NumericalRelaxation.ConvexificationBuffer1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConvexificationBuffer1D{T1,T2} &lt;: ConvexificationBuffer</code></pre><p><strong>Constructor</strong></p><ul><li><code>build_buffer</code> is the unified constructor for all <code>ConvexificationBuffer</code></li></ul><p><strong>Fields</strong></p><ul><li><code>grid::T1</code> holds the deformation gradient grid</li><li><code>values::T2</code> holds the incremental stress potential values W(F)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/koehlerson/NumericalRelaxation.jl/blob/4b1ab414c0f5dc893645f4295da8681e40bca071/src/utils.jl#L1-L9">source</a></section></article><h2 id="Adaptive-Convexification"><a class="docs-heading-anchor" href="#Adaptive-Convexification">Adaptive Convexification</a><a id="Adaptive-Convexification-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-Convexification" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NumericalRelaxation.AdaptiveGrahamScan" href="#NumericalRelaxation.AdaptiveGrahamScan"><code>NumericalRelaxation.AdaptiveGrahamScan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">    AdaptiveGrahamScan &lt;: AbstractConvexification</code></pre><p>struct that stores all relevant information for adaptive convexification.</p><p><strong>Fields</strong></p><ul><li><code>interval::Vector{Float64}</code></li><li><code>basegrid_numpoints::Int64</code></li><li><code>adaptivegrid_numpoints::Int64</code></li><li><code>exponent::Int64</code></li><li><code>distribution::String</code></li><li><code>stepSizeIgnoreHessian::Float64</code></li><li><code>minPointsPerInterval::Int64</code></li><li><code>radius::Float64</code></li><li><code>minStepSize::Float64</code></li><li><code>forceAdaptivity::Bool</code></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">AdaptiveGrahamScan(interval; basegrid_numpoints=50, adaptivegrid_numpoints=115, exponent=5, distribution=&quot;fix&quot;, stepSizeIgnoreHessian=0.05, minPointsPerInterval=15, radius=3, minStepSize=0.03, forceAdaptivity=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/koehlerson/NumericalRelaxation.jl/blob/4b1ab414c0f5dc893645f4295da8681e40bca071/src/convexify.jl#L58-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalRelaxation.AdaptiveConvexificationBuffer1D" href="#NumericalRelaxation.AdaptiveConvexificationBuffer1D"><code>NumericalRelaxation.AdaptiveConvexificationBuffer1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AdaptiveConvexificationBuffer1D{T1,T2,T3} &lt;: ConvexificationBuffer</code></pre><p><strong>Constructor</strong></p><ul><li><code>build_buffer</code> is the unified constructor for all <code>ConvexificationBuffer</code></li></ul><p><strong>Fields</strong></p><ul><li><code>basebuffer::ConvexificationBuffer{T1,T2}</code> holds the coarse grid buffers</li><li><code>adaptivebuffer::ConvexificationBuffer{T1,T2}</code> holds the adapted grid buffers</li><li><code>basegrid_∂²W::T3</code> second derivative information on coarse grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/koehlerson/NumericalRelaxation.jl/blob/4b1ab414c0f5dc893645f4295da8681e40bca071/src/utils.jl#L15-L24">source</a></section></article><p>To reduce the absolute computational cost of the convexification algorithm it is essential to represent the incremental stress potential <span>$W(\boldsymbol{F})$</span> on as less grid points as possible. For accuracy reasons of the resulting convex hull, the resolution of the grid must be fairly high around the supporting points <span>$F^-$</span> and <span>$F^+$</span> of non-convex regions of <span>$W$</span>. In adaptive convexification we first identify a set of points of interest based on a coarse grid to construct an adaptive grid in a second step. The adaptive grid then has a high resolution around the previously identified points and a coarse resolution everywhere inbetween. An example of the coarse and the adaptive grid can be seen in the figure below.</p><p><img src="../../assets/TimosPlot_Praeambel.svg" alt="Image"/></p><h4 id="How-to-use-it"><a class="docs-heading-anchor" href="#How-to-use-it">How to use it</a><a id="How-to-use-it-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-use-it" title="Permalink"></a></h4><p>Simply use an instance of <code>AdaptiveGrahamScan</code> and build a buffer with <code>buildbuffer</code>. The <code>convexify</code> function will then dispatch on the assigned strategy.</p><pre><code class="nohighlight hljs">adaptiveconvexification = AdaptiveGrahamScan(interval=[0.001, 20.001])
buffer = build_buffer(adaptiveconvexification)
W, F⁺, F⁻ = convexify(adaptiveconvexification,buffer,W,Tensor{2,1}((2.0,)))</code></pre><ul><li><code>interval::Vector{Float64}</code></li></ul><p>Specifies here the discretization interval for the convexification grid. In some cases default settings for adaptive convexification will not fit for the problem at hand. In this case the default values for the keyword arguments</p><ul><li><code>basegrid_numpoints::Int64 = 50</code></li><li><code>adaptivegrid_numpoints::Int64 = 1150</code></li><li><code>exponent::Int64 = 5</code></li><li><code>distribution::String = &quot;fix&quot;</code></li><li><code>stepSizeIgnoreHessian::Float64 = 0.05</code></li><li><code>minPointsPerInterval::Int64 = 15</code></li><li><code>radius::Float64 = 3</code></li><li><code>minStepSize::Float64 = 0.03</code></li><li><code>forceAdaptivity::Bool = false</code></li></ul><p>of struct <code>AdaptiveGrahamScan</code> must be altered.</p><p>In general, select an interval such that it covers all non-convex parts of <span>$W(\boldsymbol{F})$</span>. <code>basegrid_numpoints</code> and <code>convexgrid_numpoints</code> must be chosen large enough to represent all relevant information of <span>$W(\boldsymbol{F})$</span> but small enough to keep computational cost low.</p><p>To understand how to set the parameters <code>minStepSize</code>, <code>radius</code> and <code>exponent</code>, that mainly characterize the distribution of the grid points on a given subinterval <span>$[F^-,F+]$</span> (subinterval between two previously identified points of interest) of the main interval, correctly, we need to understand how the distribution of the grid points works mathematically.</p><p>For each of the two distribution types there exists a function that maps a vector entry <span>$j$</span> to to a point on the given subinterval. This function is a piecewisely defined polynomial of degree <span>$p$</span>. <span>$a$</span>, <span>$b$</span>, <span>$c$</span>, <span>$d$</span>, <span>$j^{-}_{r}$</span> and <span>$j^{+}_{r}$</span> are parameters that are automatically fitted for a specific problem. <span>$j_{max}$</span> is the number of gridpoints to be distributed on a given subintervall.</p><p class="math-container">\[\begin{align*}
{var}: \mathbb{R} &amp; \longrightarrow \mathbb{R} \\
j &amp; \longmapsto
\left\{\begin{array}{ll} F^- + a \, j^p + b \, j , &amp; \text{if } j &lt; \frac{j_{\max}}{2}, \\
F^+ - \left(a \,(j_{\max} - j)^p + b \,(j_{\max} - j) \right) , &amp; \text{if } j \geq \frac{j_{\max}}{2}. \end{array} \right.
 \end{align*}\]</p><p class="math-container">\[\begin{align*}
{fix}: \mathbb{R} &amp; \longrightarrow \mathbb{R} \\
j &amp; \longmapsto
\left\{\begin{array}{ll} F^- + a \, j^p + b \, j , &amp; \text{if } j &lt; j^{-}_{r}, \\
c \, j + d, &amp; \text{if } j^{-}_{r} \leq j \leq j^{+}_{r}, \\
F^+ - \left(a \,(j_{\max} - j)^p + b \,(j_{\max} - j) \right) , &amp; \text{if } j &gt; j^{+}_{r}. \end{array} \right.
 \end{align*}\]</p><p>For distribution type &quot;var&quot; the function constists of two regions. A polynomial of  degree <span>$p$</span> on the first half of the interval <span>$[0, j_{\max}]$</span> and a mirrored version  of it on the second half of it. Distribution type &quot;fix&quot; is an extension of type &quot;var&quot;  that adds a linear part to the middle of the interval. See figures below for examples  polynomials of type &quot;fix&quot;.</p><p>Unless the lengths of all subintervals are almost equal,  one should not use distribution type &quot;var&quot;, since it has the drawback that it results  in an adaptive grid where the step size between two grid points depends heavily on the  length (<span>$F^+-F^-$</span>) of the subinterval. This way the resulting grid can have a drastically  different resolution on either side of a point of interest.</p><p>Always set the parameters of your grid in the following order:</p><ol><li><code>minStepSize</code></li></ol><p>Defines the slope of the polinomial at its start/end point. For <span>$j_{max} \rightarrow \infty$</span>  the step size of the interval at its start/end point will converge to this value. Should  be the highest value that still just serves the accuracy requirements.  Try 0.0015*length_of_interval as a starting value.</p><ol><li><code>radius</code> (only for type &quot;fix&quot;)</li></ol><p>Sets the radius <span>$\Delta F$</span> around a point of interest in which the step size increases  to the maximum value. In terms of the mathematical definition of <span>$fix$</span> this value is used  to set the parameters <span>$j^{-}_{r}$</span> and <span>$j^{+}_{r}$</span>, which are the vector indices that define  the transitions between linear and non-linear parts. See the figure above for the influence of  this parameter on the resulting polynomial. Also check the figure at the beginning of this  section to see the resulting adaptive grid. You will notice that the step size of the grid  increases equally and within a constant radius around all points of interest.</p><ol><li><code>exponent</code></li></ol><p>Sets the exponential &quot;p&quot; of the polynomial. It mainly influences the difference between  highest and lowest step size. Or in other words, for increasing polynomial degrees the grid  points will be pushed further towards the start and end points of the interval.  See figure above for the influence of this parameter on the resulting polynomial.</p><ol><li><code>convexgrid_numpoints</code></li></ol><p>The number of grid points of the adaptive grid must now be chosen intuitively.  As a starting value choose 20 points per subinterval.</p><p><img src="../../assets/Vector_Grid_Polynom_FixPol_Praeambel.svg" alt="Image"/> <img src="../../assets/Vector_Grid_Polynom_FixRad_Praeambel.svg" alt="Image"/></p><h4 id="Extended-Info"><a class="docs-heading-anchor" href="#Extended-Info">Extended Info</a><a id="Extended-Info-1"></a><a class="docs-heading-anchor-permalink" href="#Extended-Info" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="NumericalRelaxation.adaptive_1Dgrid!" href="#NumericalRelaxation.adaptive_1Dgrid!"><code>NumericalRelaxation.adaptive_1Dgrid!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    function adaptive_1Dgrid!(ac::AdaptiveGrahamScan, ac_buffer::AdaptiveConvexificationBuffer1D{T1,T2,T3}) where {T1,T2,T3}
        ...
        return  F⁺⁻
    end</code></pre><p>Based on any grid <code>ac_buffer.basebuffer.grid</code> and coresponding function values <code>ac_buffer.basebuffer.values</code> and  its second derivative <code>ac_buffer.basegrid_∂²W</code>, a set of points of interest <code>F⁺⁻</code> will be determined. Based on this set of points and different parameters stored in <code>ac</code> an adaptive grid will be constructed such that grid resolution is highest at these points.</p><p>The resultiong grid will be broadcasted into <code>ac_buffer.adaptivebuffer.grid</code>.</p><p>F⁺⁻ will be determined by checking the slope of mathematical function W(F). Start and end points of non-convex subintervals will be stored. Additionally all minima of ∂²W(F) serve as points of interest as well (only if step size at this point is greater than <code>ac.stepSizeIgnoreHessian</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/koehlerson/NumericalRelaxation.jl/blob/4b1ab414c0f5dc893645f4295da8681e40bca071/src/convexify.jl#L199-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalRelaxation.build_buffer" href="#NumericalRelaxation.build_buffer"><code>NumericalRelaxation.build_buffer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">build_buffer(convexstrategy::T) where T&lt;:AbstractConvexification</code></pre><p>Maps a given convexification strategy <code>convexstrategy</code> to an associated buffer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/koehlerson/NumericalRelaxation.jl/blob/4b1ab414c0f5dc893645f4295da8681e40bca071/src/convexify.jl#L558-L561">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalRelaxation.convexify_nondeleting!" href="#NumericalRelaxation.convexify_nondeleting!"><code>NumericalRelaxation.convexify_nondeleting!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convexify_nondeleting!(F, W)</code></pre><p>Kernel function that implements the actual convexification without deletion in <span>$\mathcal{O}(N)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/koehlerson/NumericalRelaxation.jl/blob/4b1ab414c0f5dc893645f4295da8681e40bca071/src/convexify.jl#L140-L143">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../r1convexification/">Rank-One Convexification »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 12 December 2023 13:18">Tuesday 12 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
